#   data_log.water1,
#   tele_wl_detail.left_bank,
#   tele_wl_detail.right_bank,
#   tele_wl_detail.ground_level
# FROM
#   data_log
# inner join tele_wl_detail on tele_wl_detail.code = data_log.code
# where data_log.water1 is not null and data_log.date = DATE '2012-02-28'
# and tele_wl_detail.left_bank > tele_wl_detail.right_bank
# limit 20")
# rs$max_bank <- getMaxBank(rs)
# rs
#searchBoundaryProblem(rs)
# dbDisconnect(con);
# dbUnloadDriver(drv);
source('db_connection.R')
# Calculate max bank of water data by max(leftBank, rightBank)
getMaxBank <- function(leftBank, rightBank) {
if( is.na(leftBank) & is.na(rightBank)) {
NA
} else {
max(leftBank, rightBank, na.rm = TRUE)
}
}
isWaterLevelHaveMachineError <- function(waterLevel) {
if(!is.na(waterLevel) & waterLevel == 999999) {
TRUE
} else {
FALSE
}
}
isOutOfBound <- function(waterLevel, groundLevel, maxBank, groundLevelOffset = -1, maxBankOffset = 4) {
if(isWaterLevelHaveMachineError(waterLevel)) {
return(FALSE)
}
if( any(is.na(c(waterLevel, groundLevel, maxBank))) ) {
return(FALSE)
}
groundLevelOffset < -1
maxBankOffset <- 4
isOverGroundLevel <- waterLevel >= groundLevel + groundLevelOffset
isUnderMaxBank <- waterLevel <= maxBank + maxBankOffset
!(isOverGroundLevel & isUnderMaxBank)
}
searchBoundaryProblem <- function(data) {
data$max_bank <- mapply(getMaxBank, data$left_bank, data$right_bank)
hasBoundaryProblem <- mapply(isOutOfBound, data$water1, data$ground_level, data$max_bank)
data[hasBoundaryProblem,]
}
groupProblem <- function(data) {
# split by station
problemByStation <- split(data, data$code)
for(code_i in seq_along(problemByStation)) {
stationName <- names(problemByStation)[[code_i]]
}
}
group <- function(data) {
startTime <- c()
endTime <- c()
dataRow <- nrow(data)
i <- 1
while(i <= dataRow) {
j <- i + 1
while(j <= dataRow) {
curr_time_str <- paste(data$date[j], data$time[j])
prev_time_str <- paste(data$date[j-1], data$time[j-1])
curr_time <- as.POSIXct(curr_time_str)
prev_time <- as.POSIXct(prev_time_str)
if(difftime(curr_time, prev_time, units="mins") <= 10) {
j <- j + 1
} else {
break
}
}
startTimeStr <- as.POSIXct( paste(data[i,"date"], data[i,"time"]))
endTimeStr <- as.POSIXct( paste(data[j-1,"date"], data[j-1,"time"]))
startTime <- c(startTime, strftime(startTimeStr))
endTime <- c(endTime, strftime(endTimeStr))
i <- j
}
list(startTime = startTime, endTime = endTime)
}
# rs <- dbGetQuery(con, "SELECT
#   data_log.code,
#   data_log.date,
#   data_log.time,
#   data_log.water1,
#   tele_wl_detail.left_bank,
#   tele_wl_detail.right_bank,
#   tele_wl_detail.ground_level
# FROM
#   data_log
# inner join tele_wl_detail on tele_wl_detail.code = data_log.code
# where data_log.water1 is not null and data_log.date = DATE '2012-02-28'
# and tele_wl_detail.left_bank > tele_wl_detail.right_bank
# limit 20")
# rs$max_bank <- getMaxBank(rs)
# rs
#searchBoundaryProblem(rs)
# dbDisconnect(con);
# dbUnloadDriver(drv);
group(z2)
p <- group(z2)
cbind(p$startTime, p$endTime)
source('db_connection.R')
# Calculate max bank of water data by max(leftBank, rightBank)
getMaxBank <- function(leftBank, rightBank) {
if( is.na(leftBank) & is.na(rightBank)) {
NA
} else {
max(leftBank, rightBank, na.rm = TRUE)
}
}
isWaterLevelHaveMachineError <- function(waterLevel) {
if(!is.na(waterLevel) & waterLevel == 999999) {
TRUE
} else {
FALSE
}
}
isOutOfBound <- function(waterLevel, groundLevel, maxBank, groundLevelOffset = -1, maxBankOffset = 4) {
if(isWaterLevelHaveMachineError(waterLevel)) {
return(FALSE)
}
if( any(is.na(c(waterLevel, groundLevel, maxBank))) ) {
return(FALSE)
}
groundLevelOffset < -1
maxBankOffset <- 4
isOverGroundLevel <- waterLevel >= groundLevel + groundLevelOffset
isUnderMaxBank <- waterLevel <= maxBank + maxBankOffset
!(isOverGroundLevel & isUnderMaxBank)
}
searchBoundaryProblem <- function(data) {
data$max_bank <- mapply(getMaxBank, data$left_bank, data$right_bank)
hasBoundaryProblem <- mapply(isOutOfBound, data$water1, data$ground_level, data$max_bank)
data[hasBoundaryProblem,]
}
groupProblem <- function(data) {
# split by station
problemByStation <- split(data, data$code)
for(code_i in seq_along(problemByStation)) {
stationName <- names(problemByStation)[[code_i]]
}
}
group <- function(data) {
startTime <- c()
endTime <- c()
num <- c()
dataRow <- nrow(data)
i <- 1
while(i <= dataRow) {
j <- i + 1
while(j <= dataRow) {
curr_time_str <- paste(data$date[j], data$time[j])
prev_time_str <- paste(data$date[j-1], data$time[j-1])
curr_time <- as.POSIXct(curr_time_str)
prev_time <- as.POSIXct(prev_time_str)
if(difftime(curr_time, prev_time, units="mins") <= 10) {
j <- j + 1
} else {
break
}
}
startTimeStr <- as.POSIXct( paste(data[i,"date"], data[i,"time"]))
endTimeStr <- as.POSIXct( paste(data[j-1,"date"], data[j-1,"time"]))
startTime <- c(startTime, strftime(startTimeStr))
endTime <- c(endTime, strftime(endTimeStr))
num <- c(num, j-i)
i <- j
}
data.frame(startTime = startTime, endTime = endTime, num=num)
}
# rs <- dbGetQuery(con, "SELECT
#   data_log.code,
#   data_log.date,
#   data_log.time,
#   data_log.water1,
#   tele_wl_detail.left_bank,
#   tele_wl_detail.right_bank,
#   tele_wl_detail.ground_level
# FROM
#   data_log
# inner join tele_wl_detail on tele_wl_detail.code = data_log.code
# where data_log.water1 is not null and data_log.date = DATE '2012-02-28'
# and tele_wl_detail.left_bank > tele_wl_detail.right_bank
# limit 20")
# rs$max_bank <- getMaxBank(rs)
# rs
#searchBoundaryProblem(rs)
# dbDisconnect(con);
# dbUnloadDriver(drv);
group(z2)
z
z2
start <- as.POSIXct("2014-01-01")
start
end <- as.POSIXct("2014-01-30")
end
source('db_connection.R')
getWaterLevelData <- function(startDateTime, endDateTime) {
con <- openDbConnection()
startDateString <- strftime(startDateTime, "%Y-%m-%d");
endDateString   <- strftime(endDateTime, "%Y-%m-%d");
startTimeString <- strftime(startDateTime, "%H:%M:%S");
endTimeString   <- strftime(endDateTime, "%H:%M:%S");
data <- dbGetQuery(con,
paste("
SELECT
data_log.code,
data_log.date,
data_log.time,
data_log.water1,
tele_wl_detail.left_bank,
tele_wl_detail.right_bank,
tele_wl_detail.ground_level
FROM data_log
INNER JOIN tele_wl_detail ON tele_wl_detail.code = data_log.code
WHERE
(data_log.date > DATE '", startDateString ,"'
OR
data_log.date = DATE '", startDateString ,"' AND data_log.time >= TIME '", startTimeString ,"')
AND
(data_log.date < DATE '", endDateString ,"'
OR
data_log.date = DATE '", endDateString ,"' AND data_log.time < TIME '", endTimeString ,"')
", sep="")
)
closeDbConnection(con)
return(data)
}
get24HrWaterLevelData <- function (startDateTime = NA, endDateTime = Sys.time()) {
last24Hr <- endDateTime - 24*60*60
if(is.na(startDateTime) | last24Hr > startDateTime) {
startDateTime <- last24Hr
}
getWaterLevelData(startDateTime, endDateTime)
}
getWaterLevelData(start,end)
system.time(z <- getWaterLevelData(start,end))
getWaterLevelData(start,end)
z
source('db_connection.R')
# Calculate max bank of water data by max(leftBank, rightBank)
getMaxBank <- function(leftBank, rightBank) {
if( is.na(leftBank) & is.na(rightBank)) {
NA
} else {
max(leftBank, rightBank, na.rm = TRUE)
}
}
isWaterLevelHaveMachineError <- function(waterLevel) {
if(!is.na(waterLevel) & waterLevel == 999999) {
TRUE
} else {
FALSE
}
}
isOutOfBound <- function(waterLevel, groundLevel, maxBank, groundLevelOffset = -1, maxBankOffset = 4) {
if(isWaterLevelHaveMachineError(waterLevel)) {
return(FALSE)
}
if( any(is.na(c(waterLevel, groundLevel, maxBank))) ) {
return(FALSE)
}
groundLevelOffset < -1
maxBankOffset <- 4
isOverGroundLevel <- waterLevel >= groundLevel + groundLevelOffset
isUnderMaxBank <- waterLevel <= maxBank + maxBankOffset
!(isOverGroundLevel & isUnderMaxBank)
}
searchBoundaryProblem <- function(data) {
data$max_bank <- mapply(getMaxBank, data$left_bank, data$right_bank)
hasBoundaryProblem <- mapply(isOutOfBound, data$water1, data$ground_level, data$max_bank)
data[hasBoundaryProblem,]
}
groupProblem <- function(data) {
# split by station
problemByStation <- split(data, data$code)
for(code_i in seq_along(problemByStation)) {
stationName <- names(problemByStation)[[code_i]]
}
}
group <- function(data) {
startTime <- c()
endTime <- c()
num <- c()
dataRow <- nrow(data)
i <- 1
while(i <= dataRow) {
j <- i + 1
while(j <= dataRow) {
curr_time_str <- paste(data$date[j], data$time[j])
prev_time_str <- paste(data$date[j-1], data$time[j-1])
curr_time <- as.POSIXct(curr_time_str)
prev_time <- as.POSIXct(prev_time_str)
if(difftime(curr_time, prev_time, units="mins") <= 10) {
j <- j + 1
} else {
break
}
}
startTimeStr <- as.POSIXct( paste(data[i,"date"], data[i,"time"]))
endTimeStr <- as.POSIXct( paste(data[j-1,"date"], data[j-1,"time"]))
startTime <- c(startTime, strftime(startTimeStr))
endTime <- c(endTime, strftime(endTimeStr))
num <- c(num, j-i)
i <- j
}
data.frame(startTime = startTime, endTime = endTime, num=num)
}
# rs <- dbGetQuery(con, "SELECT
#   data_log.code,
#   data_log.date,
#   data_log.time,
#   data_log.water1,
#   tele_wl_detail.left_bank,
#   tele_wl_detail.right_bank,
#   tele_wl_detail.ground_level
# FROM
#   data_log
# inner join tele_wl_detail on tele_wl_detail.code = data_log.code
# where data_log.water1 is not null and data_log.date = DATE '2012-02-28'
# and tele_wl_detail.left_bank > tele_wl_detail.right_bank
# limit 20")
# rs$max_bank <- getMaxBank(rs)
# rs
#searchBoundaryProblem(rs)
# dbDisconnect(con);
# dbUnloadDriver(drv);
bd <- searchBoundaryProblem(z)
bd
start <- as.POSIXct("2014-02-01")
end <- as.POSIXct("2014-02-28")
getWaterLevelData(start, end)
data <- getWaterLevelData(start, end)
data
bd <- searchBoundaryProblem(data)
start <- as.POSIXct("2014-02-01")
start <- as.POSIXct("2014-03-01")
end <- as.POSIXct("2014-03-30")
data <- getWaterLevelData(start, end)
bd <- searchBoundaryProblem(data)
start <- as.POSIXct("2014-04-01")
end <- as.POSIXct("2014-04-30")
data <- getWaterLevelData(start, end)
bd <- searchBoundaryProblem(data)
start <- as.POSIXct("2014-05-01")
end <- as.POSIXct("2014-05-30")
data <- getWaterLevelData(start, end)
bd <- searchBoundaryProblem(data)
start <- as.POSIXct("2014-06-01")
end <- as.POSIXct("2014-06-30")
data <- getWaterLevelData(start, end)
bd <- searchBoundaryProblem(data)
start <- as.POSIXct("2014-07-01")
end <- as.POSIXct("2014-07-30")
data <- getWaterLevelData(start, end)
source('db_connection.R')
getWaterLevelData <- function(startDateTime, endDateTime) {
con <- openDbConnection()
startDateString <- strftime(startDateTime, "%Y-%m-%d");
endDateString   <- strftime(endDateTime, "%Y-%m-%d");
startTimeString <- strftime(startDateTime, "%H:%M:%S");
endTimeString   <- strftime(endDateTime, "%H:%M:%S");
data <- dbGetQuery(con,
paste("
SELECT
data_log.code,
data_log.date,
data_log.time,
data_log.water1,
tele_wl_detail.left_bank,
tele_wl_detail.right_bank,
tele_wl_detail.ground_level
FROM data_log
INNER JOIN tele_wl_detail ON tele_wl_detail.code = data_log.code
WHERE
(data_log.date > DATE '", startDateString ,"'
OR
data_log.date = DATE '", startDateString ,"' AND data_log.time >= TIME '", startTimeString ,"')
AND
(data_log.date < DATE '", endDateString ,"'
OR
data_log.date = DATE '", endDateString ,"' AND data_log.time < TIME '", endTimeString ,"')
", sep="")
)
closeDbConnection(con)
return(data)
}
get24HrWaterLevelData <- function (startDateTime = NA, endDateTime = Sys.time()) {
last24Hr <- endDateTime - 24*60*60
if(is.na(startDateTime) | last24Hr > startDateTime) {
startDateTime <- last24Hr
}
getWaterLevelData(startDateTime, endDateTime)
}
source('db_connection.R')
# Calculate max bank of water data by max(leftBank, rightBank)
getMaxBank <- function(leftBank, rightBank) {
if( is.na(leftBank) & is.na(rightBank)) {
NA
} else {
max(leftBank, rightBank, na.rm = TRUE)
}
}
isWaterLevelHaveMachineError <- function(waterLevel) {
if(!is.na(waterLevel) & waterLevel == 999999) {
TRUE
} else {
FALSE
}
}
isOutOfBound <- function(waterLevel, groundLevel, maxBank, groundLevelOffset = -1, maxBankOffset = 4) {
if(isWaterLevelHaveMachineError(waterLevel)) {
return(FALSE)
}
if( any(is.na(c(waterLevel, groundLevel, maxBank))) ) {
return(FALSE)
}
groundLevelOffset < -1
maxBankOffset <- 4
isOverGroundLevel <- waterLevel >= groundLevel + groundLevelOffset
isUnderMaxBank <- waterLevel <= maxBank + maxBankOffset
!(isOverGroundLevel & isUnderMaxBank)
}
searchBoundaryProblem <- function(data) {
data$max_bank <- mapply(getMaxBank, data$left_bank, data$right_bank)
hasBoundaryProblem <- mapply(isOutOfBound, data$water1, data$ground_level, data$max_bank)
data[hasBoundaryProblem,]
}
groupProblem <- function(data) {
# split by station
problemByStation <- split(data, data$code)
for(code_i in seq_along(problemByStation)) {
stationName <- names(problemByStation)[[code_i]]
}
}
group <- function(data) {
startTime <- c()
endTime <- c()
num <- c()
dataRow <- nrow(data)
i <- 1
while(i <= dataRow) {
j <- i + 1
while(j <= dataRow) {
curr_time_str <- paste(data$date[j], data$time[j])
prev_time_str <- paste(data$date[j-1], data$time[j-1])
curr_time <- as.POSIXct(curr_time_str)
prev_time <- as.POSIXct(prev_time_str)
if(difftime(curr_time, prev_time, units="mins") <= 10) {
j <- j + 1
} else {
break
}
}
startTimeStr <- as.POSIXct( paste(data[i,"date"], data[i,"time"]))
endTimeStr <- as.POSIXct( paste(data[j-1,"date"], data[j-1,"time"]))
startTime <- c(startTime, strftime(startTimeStr))
endTime <- c(endTime, strftime(endTimeStr))
num <- c(num, j-i)
i <- j
}
data.frame(startTime = startTime, endTime = endTime, num=num)
}
# rs <- dbGetQuery(con, "SELECT
#   data_log.code,
#   data_log.date,
#   data_log.time,
#   data_log.water1,
#   tele_wl_detail.left_bank,
#   tele_wl_detail.right_bank,
#   tele_wl_detail.ground_level
# FROM
#   data_log
# inner join tele_wl_detail on tele_wl_detail.code = data_log.code
# where data_log.water1 is not null and data_log.date = DATE '2012-02-28'
# and tele_wl_detail.left_bank > tele_wl_detail.right_bank
# limit 20")
# rs$max_bank <- getMaxBank(rs)
# rs
#searchBoundaryProblem(rs)
# dbDisconnect(con);
# dbUnloadDriver(drv);
start = as.POSIXct("2012-02-28")
end = as.POSIXct("2012-03-28")
data <- getWaterLevelData(start, end)
dat
data
searchBoundaryProblem(data)
bd <- searchBoundaryProblem(data)
groupProblem(bd)
problemByStation <- split(bd, bd$code)
problemByStation
p <- problemByStation
p
group(p$MUN006)
p$MUN006
p$MUN006[order(date, time),]
p$MUN006[order(date),]
p$MUN006[order(pdate),]
z <- p$MUN006
z
z[order(z$date, $time),]
z[order(z$date, $time),]
z$date
z[order(z$date, z$time),]
z2 <- z[order(z$date, z$time),]
group(z2)
z
z2
