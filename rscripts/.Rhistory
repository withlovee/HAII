source('boundary.R')
boundary.test.suite <- defineTestSuite("boundary",
dirs = file.path("tests"),
testFileRegexp = '^test\\.boundary\\.\\d+\\.R')
boundary.test.result <- runTestSuite(boundary.test.suite)
##### Testing email.R
source('email.R')
email.test.suite <- defineTestSuite("email",
dirs = file.path("tests"),
testFileRegexp = '^test\\.email\\.\\d+\\.R')
email.test.result <- runTestSuite(email.test.suite)
### print result
printTextProtocol(boundary.test.result)
printTextProtocol(email.test.result)
source('db_connection.R')
# Calculate max bank of water data by max(leftBank, rightBank)
getMaxBank <- function(leftBank, rightBank) {
if( is.na(leftBank) & is.na(rightBank)) {
NA
} else {
max(leftBank, rightBank, na.rm = TRUE)
}
}
isWaterLevelHaveMachineError <- function(waterLevel) {
if(!is.na(waterLevel) & waterLevel == 999999) {
TRUE
} else {
FALSE
}
}
isWaterLevelOutOfBound <- function(waterLevel, groundLevel, maxBank, groundLevelOffset = -1, maxBankOffset = 4) {
if(isWaterLevelHaveMachineError(waterLevel)) {
return(FALSE)
}
if( any(is.na(c(waterLevel, groundLevel, maxBank))) ) {
return(FALSE)
}
groundLevelOffset < -1
maxBankOffset <- 4
isOverGroundLevel <- waterLevel >= groundLevel + groundLevelOffset
isUnderMaxBank <- waterLevel <= maxBank + maxBankOffset
!(isOverGroundLevel & isUnderMaxBank)
}
isRainLevelOutOfBound <- function(rainLevel) {
if(rainLevel < 0 | rainLevel > 150) {
return(TRUE)
} else {
return(FALSE)
}
}
searchBoundaryProblem <- function(dataType, data) {
if(nrow(data) <= 0) {
return(NA)
}
hasBoundaryProblem <- FALSE
if(dataType == "WATER") {
data$max_bank <- mapply(getMaxBank, data$left_bank, data$right_bank)
hasBoundaryProblem <- mapply(isWaterLevelOutOfBound, data$water1, data$ground_level, data$max_bank)
} else if(dataType == "RAIN") {
hasBoundaryProblem <- mapply(isRainLevelOutOfBound, data$rain1h)
} else {
return(NA)
}
bd <- data[hasBoundaryProblem,]
if(nrow(bd) <= 0) {
return(NA)
}
bd$datetime <- mapply(paste, bd$date, bd$time)
bdProblem <- data.frame(station_code = bd$code,
problem_type = "BD",
data_type = dataType,
start_datetime = bd$datetime,
end_datetime = bd$datetime,
num = 1
)
bdProblem <- bdProblem[order(bdProblem$start_datetime), ]
return(bdProblem)
}
data <- generateSampleRainDataWithBoundaryProblem()
results <- searchBoundaryProblem("RAIN", data)
data
results
data <- generateSampleRainDataWithBoundaryProblem()
data
data$rain1h
data$rain1h[1]
class(data$rain1h[1])
pai
pai$rain1h
pai$rain1h[1]
class(pai$rain1h[1])
getDataBD <- function() {
# Condition: Passed if max_bank + 4 and ground_level - 1
# CHI001: Passed (Above right_bank but below left_bank)
# CHI002: Passed (Below both banks)
# KRN001: Below ground level
# KRN002: Above maxbank (left)
# KRN003: Above maxbank (right)
# KRN004: Below negative ground level
# code       date     time     water1 left_bank right_bank ground_level
# 1 CHI001 2012-06-08 17:00:00 999999.000   175.937    152.212      128.037
# 2 CHI002 2012-06-08 17:10:00      0.000    12.778     15.140       -2.341
# 3 KRN001 2012-06-08 17:20:00     12.200   175.937    152.212      143.435
# 4 KRN002 2012-06-08 00:00:00    136.060     9.830     15.412       -2.200
# 5 KRN003 2012-06-08 00:10:00    185.250   165.700    175.937      128.037
# 6 KRN004 2012-06-08 00:20:00    -15.432    15.937     25.230      -13.512
code <- c("CHI001", "CHI002", "KRN001", "KRN002", "KRN003", "KRN004")
date <- c("2012-06-08", "2012-06-08", "2012-06-08", "2012-06-08", "2012-06-08", "2012-06-08")
time <- c("17:00:00", "17:10:00", "17:20:00", "00:00:00", "00:10:00", "00:20:00")
water1       <- c(999999, 0, 12.2, 136.06, 185.25, -15.432)
left_bank    <- c(175.937, 12.778, 175.937, 9.83, 165.7, 15.937)
right_bank   <- c(152.212, 15.14, 152.212, 15.412, 175.937, 25.23)
ground_level <- c(128.037, -2.341, 143.435, -2.2, 128.037, -13.512)
data.frame(
code=code,
date=date,
time=time,
water1=water1,
left_bank=left_bank,
right_bank=right_bank,
ground_level=ground_level,
stringsAsFactors=FALSE
)
}
test.getMaxBank <- function() {
left_bank    <- c(10.0, 20.0, 30.0, NA  , 10.0, NA)
right_bank   <- c(10.0, 30.0, 20.0, 10.0, NA  , NA)
expected <- c(10.0, 30.0, 30.0, 10.0, 10.0, NA)
actual <- mapply(getMaxBank, left_bank, right_bank)
mapply(checkEquals, expected, actual)
}
test.isWaterLevelHaveMachineError <- function() {
checkEquals(TRUE, isWaterLevelHaveMachineError(999999))
checkEquals(FALSE, isWaterLevelHaveMachineError(123455))
checkEquals(FALSE, isWaterLevelHaveMachineError(123455.5))
}
test.isWaterLevelOutOfBound <- function() {
waterLevel  <- c(10.0, 10.0, 10.0, 10.0, NA , 0.0, 0.0)
groundLevel <- c(0.0 , 11.0, 11.5, 10.0, 0.0, NA , 0.0)
maxBank     <- c(20.0, 6.0 , 20.0, 5.0 , 0.0, 0.0, NA )
expected <- c(FALSE, FALSE, TRUE, TRUE, FALSE, FALSE, FALSE)
actual <- mapply(isWaterLevelOutOfBound, waterLevel, groundLevel, maxBank)
mapply(checkEquals, expected, actual)
}
test.searchBoundaryProblemWithNoProblem <- function() {
data <-  data.frame(
code="CHI001",
date="2014-01-01",
time="00:00:00",
water1=10,
left_bank=100,
right_bank=100,
ground_level=0,
stringsAsFactors=FALSE
)
results <- searchBoundaryProblem("WATER", data)
checkTrue( is.na(results) )
}
test.searchWaterBoundaryProblem <- function() {
# code       date     time     water1 left_bank right_bank ground_level
# 1 CHI001 2012-06-08 17:00:00 999999.000   175.937    152.212      128.037
# 2 CHI002 2012-06-08 17:10:00      0.000    12.778     15.140       -2.341
# 3 KRN001 2012-06-08 17:20:00     12.200   175.937    152.212      143.435
# 4 KRN002 2012-06-08 00:00:00    136.060     9.830     15.412       -2.200
# 5 KRN003 2012-06-08 00:10:00    185.250   165.700    175.937      128.037
# 6 KRN004 2012-06-08 00:20:00    -15.432    15.937     25.230      -13.512
data <- getDataBD()
results <- searchBoundaryProblem("WATER", data)
# Chronological Order
checkEquals("KRN002", as.character(results$station_code[1]))
checkEquals("KRN003", as.character(results$station_code[2]))
checkEquals("KRN004", as.character(results$station_code[3]))
checkEquals("KRN001", as.character(results$station_code[4]))
checkTrue(all(results$problem_type == "BD"))
checkTrue(all(results$data_type == "WATER"))
checkTrue(all(results$num == 1))
checkEquals(as.POSIXct("2012-06-08 00:00:00"), results$start_datetime[1])
checkEquals(as.POSIXct("2012-06-08 00:10:00"), results$start_datetime[2])
checkEquals(as.POSIXct("2012-06-08 00:20:00"), results$start_datetime[3])
checkEquals(as.POSIXct("2012-06-08 17:20:00"), results$start_datetime[4])
checkEquals(as.POSIXct("2012-06-08 00:00:00"), results$end_datetime[1])
checkEquals(as.POSIXct("2012-06-08 00:10:00"), results$end_datetime[2])
checkEquals(as.POSIXct("2012-06-08 00:20:00"), results$end_datetime[3])
checkEquals(as.POSIXct("2012-06-08 17:20:00"), results$end_datetime[4])
}
getDataBD()
w <- getDataBD()
w$water1
generateSampleRainDataWithBoundaryProblem <- function() {
#     code       date     time rain1h
# 1 CHI001 2012-06-08 17:00:00     -1
# 2 CHI002 2012-06-09 18:10:00      0
# 3 CHI003 2012-06-08 19:20:00     50
# 4 CHI004 2012-06-08 19:00:00    150
# 5 CHI005 2012-06-12 20:20:00    200
code <- c("CHI001", "CHI002", "CHI003", "CHI004", "CHI005")
date <- c("2012-06-08", "2012-06-09", "2012-06-08", "2012-06-08", "2012-06-12")
time <- c("17:00:00", "18:10:00", "19:20:00", "19:00:00", "20:20:00")
rain1h <- c(-1, 0, 50, 150, 200)
data <- data.frame(
code=code,
date=date,
time=time,
rain1h=rain1h,
stringsAsFactors=FALSE
)
return(data)
}
generateSampleRainDataWithoutBoundaryProblem <- function() {
code <- c("CHI001", "CHI002")
date <- c("2012-06-08", "2012-06-12")
time <- c("17:00:00", "18:10:00")
rain1h <- c("0","150")
data <- data.frame(
code=code,
date=date,
time=time,
rain1h=rain1h,
stringsAsFactors=FALSE
)
return(data)
}
test.isRainLevelOutOfBound <- function() {
rainLevel <- c(-10, 0, 100, 150, 170)
expected <- c(TRUE, FALSE, FALSE, FALSE, TRUE)
actual <- mapply(isRainLevelOutOfBound, rainLevel)
mapply(checkEquals, expected, actual)
}
test.searchBoundaryProblemWithNoProblem <- function() {
data <- generateSampleRainDataWithoutBoundaryProblem()
results <- searchBoundaryProblem("RAIN", data)
checkTrue(is.na(results))
}
test.searchRainBoundaryProblem <- function() {
#     code       date     time rain1h
# 1 CHI001 2012-06-08 17:00:00     -1
# 2 CHI002 2012-06-09 18:10:00      0
# 3 CHI003 2012-06-08 19:20:00     50
# 4 CHI004 2012-06-08 19:00:00    150
# 5 CHI005 2012-06-12 20:20:00    200
data <- generateSampleRainDataWithBoundaryProblem()
results <- searchBoundaryProblem("RAIN", data)
# Chronological Order
checkEquals("CHI004", as.character(results$station_code[1]))
checkEquals("CHI003", as.character(results$station_code[2]))
checkEquals("CHI002", as.character(results$station_code[3]))
checkTrue(all(results$problem_type == "BD"))
checkTrue(all(results$data_type == "RAIN"))
checkTrue(all(results$num == 1))
checkEquals(as.POSIXct("2012-06-08 19:00:00"), results$start_datetime[1])
checkEquals(as.POSIXct("2012-06-08 19:20:00"), results$start_datetime[2])
checkEquals(as.POSIXct("2012-06-09 18:10:00"), results$start_datetime[3])
checkEquals(as.POSIXct("2012-06-08 19:00:00"), results$end_datetime[1])
checkEquals(as.POSIXct("2012-06-08 19:20:00"), results$end_datetime[2])
checkEquals(as.POSIXct("2012-06-09 18:10:00"), results$end_datetime[3])
}
data <- generateSampleRainDataWithBoundaryProblem()
results <- searchBoundaryProblem("RAIN", data)
w$water1
data
results
library(RUnit);
##### Testing boundary.R
source('boundary.R')
boundary.test.suite <- defineTestSuite("boundary",
dirs = file.path("tests"),
testFileRegexp = '^test\\.boundary\\.\\d+\\.R')
boundary.test.result <- runTestSuite(boundary.test.suite)
##### Testing email.R
source('email.R')
email.test.suite <- defineTestSuite("email",
dirs = file.path("tests"),
testFileRegexp = '^test\\.email\\.\\d+\\.R')
email.test.result <- runTestSuite(email.test.suite)
### print result
printTextProtocol(boundary.test.result)
printTextProtocol(email.test.result)
source('datalog.R')
source('boundary.R')
source('email.R')
dataType <- "WATER"
problemType <- "BD"
stationList <- getStationCodeList();
allBdProblem <- NA
cat("###########################################\n")
cat(" Date Executed: ")
cat(strftime(Sys.time()))
cat("\n")
cat("###########################################\n")
flush.console()
currentTime <- Sys.time()
data <- NA
for(station in stationList) {
cat("\n==========[ STATION:")
cat(station)
cat(" ]==========\n")
flush.console()
cat("Getting latest run time...\n")
flush.console()
startDateTime <- getLatestProblemCheckedTime(station, dataType, problemType)
if(!is.na(startDateTime)) {
startDateTime <- startDateTime + 1
}
str(startDateTime)
cat("Loading 24hr data...\n")
flush.console()
# data <- get24HrWaterLevelData(station, startDateTime, currentTime)
data <- get24HrRainLevelData(station, startDateTime = as.POSIXct("2012-02-20"), endDateTime = as.POSIXct("2012-02-28"), debug=TRUE)
str(data)
if(nrow(data) > 0) {
cat("Detecting BD Problem...\n")
flush.console()
bdProblem <- searchBoundaryProblem(dataType, data)
str(bdProblem)
if(is.data.frame(bdProblem)) {
if(is.na(allBdProblem)) {
allBdProblem <- bdProblem
} else {
allBdProblem <- rbind(allBdProblem, bdProblem)
}
cat("Writing Logs...\n")
flush.console()
updateProblemLog(bdProblem, 60*10)
} else {
cat("Problem not found...\n")
}
cat("Update latest runtime...\n")
flush.console()
end_datetime <- mapply(paste, data$date, data$time)
latestTime <- max(as.POSIXct(end_datetime))
updateLatestProblemCheckedTime(station, dataType, problemType, latestTime)
} else {
cat("No data...\n")
}
cat("DONE!...\n")
flush.console()
}
if(!is.na(allBdProblem)) {
cat("====================\n")
cat("Sending Emails...\n")
cat("====================\n")
flush.console()
newProblemStation <- getNewProblemStationList(dataType, problemType, currentTime, allBdProblem)
sendProblemMailNotification(dataType, problemType, currentTime, newProblemStation)
} else {
cat("====================\n")
cat("No problem found...\n")
cat("====================\n")
flush.console()
}
source('datalog.R')
source('boundary.R')
source('email.R')
dataType <- "RAIN"
problemType <- "BD"
stationList <- getStationCodeList();
allBdProblem <- NA
cat("###########################################\n")
cat(" Date Executed: ")
cat(strftime(Sys.time()))
cat("\n")
cat("###########################################\n")
flush.console()
currentTime <- Sys.time()
data <- NA
for(station in stationList) {
cat("\n==========[ STATION:")
cat(station)
cat(" ]==========\n")
flush.console()
cat("Getting latest run time...\n")
flush.console()
startDateTime <- getLatestProblemCheckedTime(station, dataType, problemType)
if(!is.na(startDateTime)) {
startDateTime <- startDateTime + 1
}
str(startDateTime)
cat("Loading 24hr data...\n")
flush.console()
# data <- get24HrWaterLevelData(station, startDateTime, currentTime)
data <- get24HrRainLevelData(station, startDateTime = as.POSIXct("2012-02-20"), endDateTime = as.POSIXct("2012-02-28"), debug=TRUE)
str(data)
if(nrow(data) > 0) {
cat("Detecting BD Problem...\n")
flush.console()
bdProblem <- searchBoundaryProblem(dataType, data)
str(bdProblem)
if(is.data.frame(bdProblem)) {
if(is.na(allBdProblem)) {
allBdProblem <- bdProblem
} else {
allBdProblem <- rbind(allBdProblem, bdProblem)
}
cat("Writing Logs...\n")
flush.console()
updateProblemLog(bdProblem, 60*10)
} else {
cat("Problem not found...\n")
}
cat("Update latest runtime...\n")
flush.console()
end_datetime <- mapply(paste, data$date, data$time)
latestTime <- max(as.POSIXct(end_datetime))
updateLatestProblemCheckedTime(station, dataType, problemType, latestTime)
} else {
cat("No data...\n")
}
cat("DONE!...\n")
flush.console()
}
if(!is.na(allBdProblem)) {
cat("====================\n")
cat("Sending Emails...\n")
cat("====================\n")
flush.console()
newProblemStation <- getNewProblemStationList(dataType, problemType, currentTime, allBdProblem)
sendProblemMailNotification(dataType, problemType, currentTime, newProblemStation)
} else {
cat("====================\n")
cat("No problem found...\n")
cat("====================\n")
flush.console()
}
library(RUnit);
##### Testing boundary.R
source('boundary.R')
boundary.test.suite <- defineTestSuite("boundary",
dirs = file.path("tests"),
testFileRegexp = '^test\\.boundary\\.\\d+\\.R')
boundary.test.result <- runTestSuite(boundary.test.suite)
##### Testing email.R
source('email.R')
email.test.suite <- defineTestSuite("email",
dirs = file.path("tests"),
testFileRegexp = '^test\\.email\\.\\d+\\.R')
email.test.result <- runTestSuite(email.test.suite)
### print result
printTextProtocol(boundary.test.result)
printTextProtocol(email.test.result)
source('datalog.R')
source('boundary.R')
source('email.R')
dataType <- "RAIN"
problemType <- "BD"
stationList <- getStationCodeList();
allBdProblem <- NA
cat("###########################################\n")
cat(" Date Executed: ")
cat(strftime(Sys.time()))
cat("\n")
cat("###########################################\n")
flush.console()
currentTime <- Sys.time()
data <- NA
for(station in stationList) {
cat("\n==========[ STATION:")
cat(station)
cat(" ]==========\n")
flush.console()
cat("Getting latest run time...\n")
flush.console()
startDateTime <- getLatestProblemCheckedTime(station, dataType, problemType)
if(!is.na(startDateTime)) {
startDateTime <- startDateTime + 1
}
str(startDateTime)
cat("Loading 24hr data...\n")
flush.console()
# data <- get24HrWaterLevelData(station, startDateTime, currentTime)
data <- get24HrRainLevelData(station, startDateTime = as.POSIXct("2012-02-20"), endDateTime = as.POSIXct("2012-02-28"), debug=TRUE)
str(data)
if(nrow(data) > 0) {
cat("Detecting BD Problem...\n")
flush.console()
bdProblem <- searchBoundaryProblem(dataType, data)
str(bdProblem)
if(is.data.frame(bdProblem)) {
if(is.na(allBdProblem)) {
allBdProblem <- bdProblem
} else {
allBdProblem <- rbind(allBdProblem, bdProblem)
}
cat("Writing Logs...\n")
flush.console()
updateProblemLog(bdProblem, 60*10)
} else {
cat("Problem not found...\n")
}
cat("Update latest runtime...\n")
flush.console()
end_datetime <- mapply(paste, data$date, data$time)
latestTime <- max(as.POSIXct(end_datetime))
updateLatestProblemCheckedTime(station, dataType, problemType, latestTime)
} else {
cat("No data...\n")
}
cat("DONE!...\n")
flush.console()
}
if(!is.na(allBdProblem)) {
cat("====================\n")
cat("Sending Emails...\n")
cat("====================\n")
flush.console()
newProblemStation <- getNewProblemStationList(dataType, problemType, currentTime, allBdProblem)
sendProblemMailNotification(dataType, problemType, currentTime, newProblemStation)
} else {
cat("====================\n")
cat("No problem found...\n")
cat("====================\n")
flush.console()
}
