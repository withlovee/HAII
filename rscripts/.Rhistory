a$hour <- 7
a$min <- 0
a$sec <- 0
a <- as.POSIXct(a)
if(a > d) {
# yesterday
a <- a - 86400
}
return(a)
}
getStartOfDayOperationDateTime <- function(date) {
dateStr <- strftime(date, "%Y-%m-%d");
return( as.POSIXct(paste(dateStr, "07:00:00")) )
}
getNewProblemStationList <- function(dataType, problemType, time, problems) {
allStationList <- levels(problems$station_code)
oldStationList <- getAlreadyCheckedStationList(dataType, problemType, time)
return(allStationList[!(allStationList %in% oldStationList)])
}
getAlreadyCheckedStationList <- function(dataType, problemType, time) {
operationDateTime <- opDate(time)
endOfOperationDateTime <- operationDateTime + 86400
operationDateTimeString <- strftime(operationDateTime, "%Y-%m-%d %H:%M:%S")
endOfOperationDateTimeString <- strftime(endOfOperationDateTime, "%Y-%m-%d %H:%M:%S")
query <- paste0("
SELECT problems.station_code
FROM problems
WHERE start_datetime >= timestamp '", operationDateTimeString ,"'
AND end_datetime < timestamp '", endOfOperationDateTimeString ,"'
AND data_type = '", dataType ,"'
AND problem_type = '", problemType ,"'
")
con <- openDbConnection()
data <- dbGetQuery(con, query)
closeDbConnection(con)
return(data$station_code)
}
updateProblemLog <- function(problems, intervalSecond) {
problems <- problems[order(problems$start_datetime), ]
con <- openDbConnection()
for(i in 1:nrow(problems)) {
p <- problems[i,]
previousDateTime <- as.POSIXct(p$start_datetime) - intervalSecond
previousDateTimeString <- strftime(previousDateTime, "%Y-%m-%d %H:%M:%S")
currentDateTimeString <- strftime(Sys.time(), "%Y-%m-%d %H:%M:%S")
operationDateTimeString <- strftime(opDate(p$start_datetime), "%Y-%m-%d %H:%M:%S")
query <- paste("
SELECT *
FROM problems
WHERE station_code = '", p$station_code ,"'
AND end_datetime = timestamp '", previousDateTimeString ,"'
AND start_datetime >= timestamp '", operationDateTimeString ,"'
AND data_type = '", p$data_type ,"'
AND problem_type = '", p$problem_type ,"'
", sep="")
previousProblem <- dbGetQuery(con, query)
# print(query)
# str(previousProblem)
if(nrow(previousProblem) > 0) {
# merge problem together
# print("update")
query <- paste("
UPDATE problems
SET
end_datetime = timestamp '", p$end_datetime ,"' ,
updated_at = timestamp '", currentDateTimeString ,"' ,
num = ",as.numeric(previousProblem$num) + 1,"
WHERE id=", previousProblem$id ,"
", sep="")
dbSendQuery(con, query)
} else {
# create new row
# print("add")
query <- paste("
INSERT INTO problems(station_code,data_type,problem_type,start_datetime,end_datetime,num,status,created_at,updated_at)
VALUES (
'", p$station_code ,"' ,
'", p$data_type ,"' ,
'", p$problem_type ,"' ,
timestamp '", p$start_datetime ,"' ,
timestamp '", p$end_datetime ,"' ,
'", p$num ,"' ,
'undefined' ,
timestamp '", currentDateTimeString ,"' ,
timestamp '", currentDateTimeString ,"'
)
", sep="")
dbSendQuery(con, query)
}
}
closeDbConnection(con);
}
getStartOfDayOperationDateTime(as.POSIXct("2012-01-01"))
stations <- getStationCodeList()
statiokns
statiokns
stations
source('/Applications/XAMPP/xamppfiles/htdocs/HAII/rscripts/boundary_batch.R')
data <- data.frame()
data
source('/Applications/XAMPP/xamppfiles/htdocs/HAII/rscripts/boundary_batch.R')
source('/Applications/XAMPP/xamppfiles/htdocs/HAII/rscripts/boundary_batch.R')
source('/Applications/XAMPP/xamppfiles/htdocs/HAII/rscripts/boundary_batch.R')
source('/Applications/XAMPP/xamppfiles/htdocs/HAII/rscripts/boundary_batch.R')
source('/Applications/XAMPP/xamppfiles/htdocs/HAII/rscripts/boundary_batch.R')
source('/Applications/XAMPP/xamppfiles/htdocs/HAII/rscripts/boundary_batch.R')
source('/Applications/XAMPP/xamppfiles/htdocs/HAII/rscripts/boundary_batch.R')
source('/Applications/XAMPP/xamppfiles/htdocs/HAII/rscripts/boundary_batch.R')
source('/Applications/XAMPP/xamppfiles/htdocs/HAII/rscripts/boundary_batch.R')
source('datalog.R')
source('boundary.R')
DAY <- 60*60*24
# change to command args later
startDateTime <- getStartOfDayOperationDateTime(as.POSIXct("2010-01-01"))
endDateTime <- getStartOfDayOperationDateTime(as.POSIXct("2014-07-01"))
boundaryBatch(startDateTime, endDateTime, "WATER")
boundaryBatch <- function(startDateTime , endDateTime, dataType) {
t <- startDateTime
stations <- getStationCodeList()
while(t < endDateTime) {
for(station in stations) {
boundaryBatchOneDay(t, station, dataType)
}
t <- t + DAY
}
}
boundaryBatchOneDay <- function(startDate, stationCode, dataType) {
data <- data.frame()
cat(startDate)
cat(stationCode)
if(dataType == "WATER") {
#data <- getWaterLevelData(stationCode, startDateTime, startDateTime + DAY)
}
# bdProblem <- searchBoundaryProblem(data=data, dataType=dataType)
# updateProblemLog(problems=bdProblem ,dataType=dataType)
}
boundaryBatch <- function(startDateTime , endDateTime, dataType) {
t <- startDateTime
stations <- getStationCodeList()
while(t < endDateTime) {
for(station in stations) {
boundaryBatchOneDay(t, station, dataType)
}
t <- t + DAY
}
}
boundaryBatchOneDay <- function(startDate, stationCode, dataType) {
data <- data.frame()
cat(startDate)
cat(stationCode)
cat("\n")
if(dataType == "WATER") {
#data <- getWaterLevelData(stationCode, startDateTime, startDateTime + DAY)
}
# bdProblem <- searchBoundaryProblem(data=data, dataType=dataType)
# updateProblemLog(problems=bdProblem ,dataType=dataType)
}
startDateTime <- getStartOfDayOperationDateTime(as.POSIXct("2010-01-01"))
endDateTime <- getStartOfDayOperationDateTime(as.POSIXct("2014-07-01"))
boundaryBatch(startDateTime, endDateTime, "WATER")
source('datalog.R')
source('boundary.R')
DAY <- 60*60*24
# change to command args later
startDateTime <- getStartOfDayOperationDateTime(as.POSIXct("2010-01-01"))
endDateTime <- getStartOfDayOperationDateTime(as.POSIXct("2014-07-01"))
boundaryBatch(startDateTime, endDateTime, "WATER")
source('datalog.R')
source('boundary.R')
DAY <- 60*60*24
boundaryBatch <- function(startDateTime , endDateTime, dataType) {
t <- startDateTime
stations <- getStationCodeList()
while(t < endDateTime) {
for(station in stations) {
boundaryBatchOneDay(t, station, dataType)
}
t <- t + DAY
}
}
boundaryBatchOneDay <- function(startDate, stationCode, dataType) {
data <- data.frame()
cat(strftime(startDate))
cat(stationCode)
cat("\n")
if(dataType == "WATER") {
#data <- getWaterLevelData(stationCode, startDateTime, startDateTime + DAY)
}
# bdProblem <- searchBoundaryProblem(data=data, dataType=dataType)
# updateProblemLog(problems=bdProblem ,dataType=dataType)
}
# change to command args later
startDateTime <- getStartOfDayOperationDateTime(as.POSIXct("2010-01-01"))
endDateTime <- getStartOfDayOperationDateTime(as.POSIXct("2014-07-01"))
boundaryBatch(startDateTime, endDateTime, "WATER")
source('datalog.R')
source('boundary.R')
DAY <- 60*60*24
boundaryBatch <- function(startDateTime , endDateTime, dataType) {
t <- startDateTime
stations <- getStationCodeList()
while(t < endDateTime) {
for(station in stations) {
boundaryBatchOneDay(t, station, dataType)
}
t <- t + DAY
}
}
boundaryBatchOneDay <- function(startDate, stationCode, dataType) {
data <- data.frame()
cat(strftime(startDate))
cat(stationCode)
cat("\n")
if(dataType == "WATER") {
data <- getWaterLevelData(stationCode, startDateTime, startDateTime + DAY)
}
# bdProblem <- searchBoundaryProblem(data=data, dataType=dataType)
# updateProblemLog(problems=bdProblem ,dataType=dataType)
}
# change to command args later
startDateTime <- getStartOfDayOperationDateTime(as.POSIXct("2010-01-01"))
endDateTime <- getStartOfDayOperationDateTime(as.POSIXct("2014-07-01"))
boundaryBatch(startDateTime, endDateTime, "WATER")
source('datalog.R')
source('boundary.R')
DAY <- 60*60*24
boundaryBatch <- function(startDateTime , endDateTime, dataType) {
t <- startDateTime
stations <- getStationCodeList()
while(t < endDateTime) {
for(station in stations) {
boundaryBatchOneDay(t, station, dataType)
}
t <- t + DAY
}
}
boundaryBatchOneDay <- function(startDateTime, stationCode, dataType) {
data <- data.frame()
cat(strftime(startDate))
cat(stationCode)
cat("\n")
if(dataType == "WATER") {
data <- getWaterLevelData(stationCode, startDateTime, startDateTime + DAY)
}
# bdProblem <- searchBoundaryProblem(data=data, dataType=dataType)
# updateProblemLog(problems=bdProblem ,dataType=dataType)
}
# change to command args later
startDateTime <- getStartOfDayOperationDateTime(as.POSIXct("2010-01-01"))
endDateTime <- getStartOfDayOperationDateTime(as.POSIXct("2014-07-01"))
boundaryBatch(startDateTime, endDateTime, "WATER")
source('datalog.R')
source('boundary.R')
DAY <- 60*60*24
boundaryBatch <- function(startDateTime , endDateTime, dataType) {
t <- startDateTime
stations <- getStationCodeList()
while(t < endDateTime) {
for(station in stations) {
boundaryBatchOneDay(t, station, dataType)
}
t <- t + DAY
}
}
boundaryBatchOneDay <- function(startDateTime, stationCode, dataType) {
data <- data.frame()
cat(strftime(startDateTime))
cat(stationCode)
cat("\n")
if(dataType == "WATER") {
data <- getWaterLevelData(stationCode, startDateTime, startDateTime + DAY)
}
# bdProblem <- searchBoundaryProblem(data=data, dataType=dataType)
# updateProblemLog(problems=bdProblem ,dataType=dataType)
}
# change to command args later
startDateTime <- getStartOfDayOperationDateTime(as.POSIXct("2010-01-01"))
endDateTime <- getStartOfDayOperationDateTime(as.POSIXct("2014-07-01"))
boundaryBatch(startDateTime, endDateTime, "WATER")
source('/Applications/XAMPP/xamppfiles/htdocs/HAII/rscripts/datalog.R')
source('/Applications/XAMPP/xamppfiles/htdocs/HAII/rscripts/datalog.R')
source('datalog.R')
source('boundary.R')
source('email.R')
dataType <- "WATER"
problemType <- "BD"
stationList <- getStationCodeList();
allBdProblem <- NA
cat("###########################################\n")
cat(" Date Executed: ")
cat(strftime(Sys.time()))
cat("\n")
cat("###########################################\n")
flush.console()
currentTime <- Sys.time()
data <- NA
for(station in stationList) {
cat("\n==========[ STATION:")
cat(station)
cat(" ]==========\n")
flush.console()
cat("Getting latest run time...\n")
flush.console()
startDateTime <- getLatestProblemCheckedTime(station, dataType, problemType)
if(!is.na(startDateTime)) {
startDateTime <- startDateTime + 1
}
str(startDateTime)
cat("Loading 24hr data...\n")
flush.console()
# data <- get24HrWaterLevelData(station, startDateTime, currentTime)
data <- get24HrWaterLevelData(station, startDateTime = as.POSIXct("2012-02-20"), endDateTime = as.POSIXct("2012-02-28"), debug=TRUE)
str(data)
if(nrow(data) > 0) {
cat("Detecting BD Problem...\n")
flush.console()
bdProblem <- searchBoundaryProblem(dataType, data)
str(bdProblem)
if(is.data.frame(bdProblem)) {
if(is.na(allBdProblem)) {
allBdProblem <- bdProblem
} else {
allBdProblem <- rbind(allBdProblem, bdProblem)
}
cat("Writing Logs...\n")
flush.console()
updateProblemLog(bdProblem, 60*10)
} else {
cat("Problem not found...\n")
}
cat("Update latest runtime...\n")
flush.console()
end_datetime <- mapply(paste, data$date, data$time)
latestTime <- max(as.POSIXct(end_datetime))
updateLatestProblemCheckedTime(station, dataType, problemType, latestTime)
} else {
cat("No data...\n")
}
cat("DONE!...\n")
flush.console()
}
if(!is.na(allBdProblem)) {
cat("====================\n")
cat("Sending Emails...\n")
cat("====================\n")
flush.console()
newProblemStation <- getNewProblemStationList(dataType, problemType, currentTime, allBdProblem)
sendProblemMailNotification(dataType, problemType, currentTime, newProblemStation)
} else {
cat("====================\n")
cat("No problem found...\n")
cat("====================\n")
flush.console()
}
source('/Applications/XAMPP/xamppfiles/htdocs/HAII/rscripts/datalog.R')
source('datalog.R')
source('boundary.R')
source('email.R')
dataType <- "WATER"
problemType <- "BD"
stationList <- getStationCodeList();
allBdProblem <- NA
cat("###########################################\n")
cat(" Date Executed: ")
cat(strftime(Sys.time()))
cat("\n")
cat("###########################################\n")
flush.console()
currentTime <- Sys.time()
data <- NA
for(station in stationList) {
cat("\n==========[ STATION:")
cat(station)
cat(" ]==========\n")
flush.console()
cat("Getting latest run time...\n")
flush.console()
startDateTime <- getLatestProblemCheckedTime(station, dataType, problemType)
if(!is.na(startDateTime)) {
startDateTime <- startDateTime + 1
}
str(startDateTime)
cat("Loading 24hr data...\n")
flush.console()
# data <- get24HrWaterLevelData(station, startDateTime, currentTime)
data <- get24HrWaterLevelData(station, startDateTime = as.POSIXct("2012-02-20"), endDateTime = as.POSIXct("2012-02-28"), debug=TRUE)
str(data)
if(nrow(data) > 0) {
cat("Detecting BD Problem...\n")
flush.console()
bdProblem <- searchBoundaryProblem(dataType, data)
str(bdProblem)
if(is.data.frame(bdProblem)) {
if(is.na(allBdProblem)) {
allBdProblem <- bdProblem
} else {
allBdProblem <- rbind(allBdProblem, bdProblem)
}
cat("Writing Logs...\n")
flush.console()
updateProblemLog(bdProblem, 60*10)
} else {
cat("Problem not found...\n")
}
cat("Update latest runtime...\n")
flush.console()
end_datetime <- mapply(paste, data$date, data$time)
latestTime <- max(as.POSIXct(end_datetime))
updateLatestProblemCheckedTime(station, dataType, problemType, latestTime)
} else {
cat("No data...\n")
}
cat("DONE!...\n")
flush.console()
}
if(!is.na(allBdProblem)) {
cat("====================\n")
cat("Sending Emails...\n")
cat("====================\n")
flush.console()
newProblemStation <- getNewProblemStationList(dataType, problemType, currentTime, allBdProblem)
sendProblemMailNotification(dataType, problemType, currentTime, newProblemStation)
} else {
cat("====================\n")
cat("No problem found...\n")
cat("====================\n")
flush.console()
}
source('/Applications/XAMPP/xamppfiles/htdocs/HAII/rscripts/datalog.R')
source('/Applications/XAMPP/xamppfiles/htdocs/HAII/rscripts/datalog.R')
source('/Applications/XAMPP/xamppfiles/htdocs/HAII/rscripts/datalog.R')
source('/Applications/XAMPP/xamppfiles/htdocs/HAII/rscripts/datalog.R')
source('/Applications/XAMPP/xamppfiles/htdocs/HAII/rscripts/datalog.R')
source('/Applications/XAMPP/xamppfiles/htdocs/HAII/rscripts/datalog.R')
source('/Applications/XAMPP/xamppfiles/htdocs/HAII/rscripts/datalog.R')
is.data.frame(NA)
!is.data.frame(NA)
source('/Applications/XAMPP/xamppfiles/htdocs/HAII/rscripts/datalog.R')
source('/Applications/XAMPP/xamppfiles/htdocs/HAII/rscripts/datalog.R')
source('datalog.R')
source('boundary.R')
source('email.R')
dataType <- "WATER"
problemType <- "BD"
stationList <- getStationCodeList();
allBdProblem <- NA
cat("###########################################\n")
cat(" Date Executed: ")
cat(strftime(Sys.time()))
cat("\n")
cat("###########################################\n")
flush.console()
currentTime <- Sys.time()
data <- NA
for(station in stationList) {
cat("\n==========[ STATION:")
cat(station)
cat(" ]==========\n")
flush.console()
cat("Getting latest run time...\n")
flush.console()
startDateTime <- getLatestProblemCheckedTime(station, dataType, problemType)
if(!is.na(startDateTime)) {
startDateTime <- startDateTime + 1
}
str(startDateTime)
cat("Loading 24hr data...\n")
flush.console()
# data <- get24HrWaterLevelData(station, startDateTime, currentTime)
data <- get24HrWaterLevelData(station, startDateTime = as.POSIXct("2012-02-20"), endDateTime = as.POSIXct("2012-02-28"), debug=TRUE)
str(data)
if(nrow(data) > 0) {
cat("Detecting BD Problem...\n")
flush.console()
bdProblem <- searchBoundaryProblem(dataType, data)
str(bdProblem)
if(is.data.frame(bdProblem)) {
if(is.na(allBdProblem)) {
allBdProblem <- bdProblem
} else {
allBdProblem <- rbind(allBdProblem, bdProblem)
}
cat("Writing Logs...\n")
flush.console()
updateProblemLog(bdProblem, 60*10)
} else {
cat("Problem not found...\n")
}
cat("Update latest runtime...\n")
flush.console()
end_datetime <- mapply(paste, data$date, data$time)
latestTime <- max(as.POSIXct(end_datetime))
updateLatestProblemCheckedTime(station, dataType, problemType, latestTime)
} else {
cat("No data...\n")
}
cat("DONE!...\n")
flush.console()
}
if(!is.na(allBdProblem)) {
cat("====================\n")
cat("Sending Emails...\n")
cat("====================\n")
flush.console()
newProblemStation <- getNewProblemStationList(dataType, problemType, currentTime, allBdProblem)
sendProblemMailNotification(dataType, problemType, currentTime, newProblemStation)
} else {
cat("====================\n")
cat("No problem found...\n")
cat("====================\n")
flush.console()
}
