# dbUnloadDriver(drv);
searchBoundaryProblem(rs)
source('db_connection.R')
# Calculate max bank of water data by max(leftBank, rightBank)
# params:
#   data.frame waterData - Data frame of water level and station detail
# return:
#   vector - maximum bank level
getMaxBank <- function(waterData) {
# bind left and right bank level together
leftRightBank <- cbind(waterData$left_bank, waterData$right_bank)
# return vector of pairwise maximum
apply(leftRightBank, 1, max)
}
isOutOfBound <- function(waterLevel, groundLevel, maxBank, groundLevelOffset = -1, maxBankOffset = 4) {
groundLevelOffset < -1
maxBankOffset <- 4
isOverGroundLevel <- waterLevel >= groundLevel + groundLevelOffset
isUnderMaxBank <- waterLevel <= maxBank + maxBankOffset
!(isOverGroundLevel & isUnderMaxBank)
}
searchBoundaryProblem <- function(data) {
data$max_bank <- getMaxBank(data)
hasBoundaryProblem <- mapply(isOutOfBound, data$water1, data$ground_level, data$max_bank)
data[hasBoundaryProblem,]
}
rs <- dbGetQuery(con, "SELECT
data_log.code,
data_log.date,
data_log.time,
data_log.water1,
tele_wl_detail.code,
tele_wl_detail.left_bank,
tele_wl_detail.right_bank,
tele_wl_detail.ground_level
FROM
data_log
inner join tele_wl_detail on tele_wl_detail.code = data_log.code
where data_log.water1 is not null and data_log.date = DATE '2013-02-28'
and tele_wl_detail.left_bank > tele_wl_detail.right_bank
limit 20")
rs$max_bank <- getMaxBank(rs)
rs
dbDisconnect(con);
# dbUnloadDriver(drv);
rs
searchBoundaryProblem(rs)
source('db_connection.R')
# Calculate max bank of water data by max(leftBank, rightBank)
# params:
#   data.frame waterData - Data frame of water level and station detail
# return:
#   vector - maximum bank level
getMaxBank <- function(waterData) {
# bind left and right bank level together
leftRightBank <- cbind(waterData$left_bank, waterData$right_bank)
# return vector of pairwise maximum
apply(leftRightBank, 1, max)
}
isOutOfBound <- function(waterLevel, groundLevel, maxBank, groundLevelOffset = -1, maxBankOffset = 4) {
groundLevelOffset < -1
maxBankOffset <- 4
isOverGroundLevel <- waterLevel >= groundLevel + groundLevelOffset
isUnderMaxBank <- waterLevel <= maxBank + maxBankOffset
!(isOverGroundLevel & isUnderMaxBank)
}
searchBoundaryProblem <- function(data) {
data$max_bank <- getMaxBank(data)
hasBoundaryProblem <- mapply(isOutOfBound, data$water1, data$ground_level, data$max_bank)
data[hasBoundaryProblem,]
}
rs <- dbGetQuery(con, "SELECT
data_log.code,
data_log.date,
data_log.time,
data_log.water1,
tele_wl_detail.code,
tele_wl_detail.left_bank,
tele_wl_detail.right_bank,
tele_wl_detail.ground_level
FROM
data_log
inner join tele_wl_detail on tele_wl_detail.code = data_log.code
where data_log.water1 is not null and data_log.date = DATE '2012-02-28'
and tele_wl_detail.left_bank > tele_wl_detail.right_bank
limit 2000")
rs$max_bank <- getMaxBank(rs)
rs
dbDisconnect(con);
# dbUnloadDriver(drv);
isOutOfBound(rs)
getDataBD <- function() {
# Condition: Passed if max_bank + 4 and ground_level - 1
# CHI001: Passed (Above right_bank but below left_bank)
# CHI002: Passed (Below both banks)
# KRN001: Below ground level
# KRN002: Above maxbank (left)
# KRN003: Above maxbank (right)
# KRN004: Below negative ground level
code <- c("CHI001","CHI002","KRN001", "KRN002", "KRN003", "KRN004")
date <- c("2012-06-08", "2012-06-08", "2012-06-08", "2012-06-08", "2012-06-08", "2012-06-08")
time <- c("17:00:00", "17:10:00", "17:20:00", "00:00:00", "00:10:00", "00:20:00")
water1       <- c("166.53", "0", "12.2", "136.06", "185.25", "-15.432")
left_bank    <- c("175.937", "12.778", "175.937","9.83", "165.7", "15.937")
right_bank   <- c("152.212", "15.14", "152.212","15.412", "175.937", "25.23")
ground_level <- c("128.037", "-2.341", "143.435", "-2.2", "128.037", "-13.512")
data.frame(
code=code,
date=date,
time=time,
water1=water1,
left_bank=left_bank,
right_bank=right_bank,
ground_level=ground_level
)
}
getData()
getDataDB()
getDataBD()
x <- getDataBD()
searchBoundaryProblem(x)
warnings()
x
source('db_connection.R')
# Calculate max bank of water data by max(leftBank, rightBank)
# params:
#   data.frame waterData - Data frame of water level and station detail
# return:
#   vector - maximum bank level
getMaxBank <- function(waterData) {
# bind left and right bank level together
leftRightBank <- cbind(waterData$left_bank, waterData$right_bank)
# return vector of pairwise maximum
apply(leftRightBank, 1, max)
}
isOutOfBound <- function(waterLevel, groundLevel, maxBank, groundLevelOffset = -1, maxBankOffset = 4) {
groundLevelOffset < -1
maxBankOffset <- 4
isOverGroundLevel <- waterLevel >= groundLevel + groundLevelOffset
isUnderMaxBank <- waterLevel <= maxBank + maxBankOffset
!(isOverGroundLevel & isUnderMaxBank)
}
searchBoundaryProblem <- function(data) {
data$max_bank <- getMaxBank(data)
str(data)
hasBoundaryProblem <- mapply(isOutOfBound, data$water1, data$ground_level, data$max_bank)
data[hasBoundaryProblem,]
}
rs <- dbGetQuery(con, "SELECT
data_log.code,
data_log.date,
data_log.time,
data_log.water1,
tele_wl_detail.code,
tele_wl_detail.left_bank,
tele_wl_detail.right_bank,
tele_wl_detail.ground_level
FROM
data_log
inner join tele_wl_detail on tele_wl_detail.code = data_log.code
where data_log.water1 is not null and data_log.date = DATE '2012-02-28'
and tele_wl_detail.left_bank > tele_wl_detail.right_bank
limit 2000")
rs$max_bank <- getMaxBank(rs)
rs
dbDisconnect(con);
# dbUnloadDriver(drv);
x <- getDataBD()
x
searchBoundaryProblem(x)
warnings()
source('db_connection.R')
# Calculate max bank of water data by max(leftBank, rightBank)
# params:
#   data.frame waterData - Data frame of water level and station detail
# return:
#   vector - maximum bank level
getMaxBank <- function(waterData) {
# bind left and right bank level together
leftRightBank <- cbind(waterData$left_bank, waterData$right_bank)
# return vector of pairwise maximum
apply(leftRightBank, 1, max)
}
isOutOfBound <- function(waterLevel, groundLevel, maxBank, groundLevelOffset = -1, maxBankOffset = 4) {
groundLevelOffset < -1
maxBankOffset <- 4
str(groundLevel)
isOverGroundLevel <- waterLevel >= groundLevel + groundLevelOffset
isUnderMaxBank <- waterLevel <= maxBank + maxBankOffset
!(isOverGroundLevel & isUnderMaxBank)
}
searchBoundaryProblem <- function(data) {
data$max_bank <- getMaxBank(data)
hasBoundaryProblem <- mapply(isOutOfBound, data$water1, data$ground_level, data$max_bank)
data[hasBoundaryProblem,]
}
rs <- dbGetQuery(con, "SELECT
data_log.code,
data_log.date,
data_log.time,
data_log.water1,
tele_wl_detail.code,
tele_wl_detail.left_bank,
tele_wl_detail.right_bank,
tele_wl_detail.ground_level
FROM
data_log
inner join tele_wl_detail on tele_wl_detail.code = data_log.code
where data_log.water1 is not null and data_log.date = DATE '2012-02-28'
and tele_wl_detail.left_bank > tele_wl_detail.right_bank
limit 2000")
rs$max_bank <- getMaxBank(rs)
rs
dbDisconnect(con);
# dbUnloadDriver(drv);
searchBoundaryProblem(x)
x
x$ground_level
source('db_connection.R')
# Calculate max bank of water data by max(leftBank, rightBank)
# params:
#   data.frame waterData - Data frame of water level and station detail
# return:
#   vector - maximum bank level
getMaxBank <- function(waterData) {
# bind left and right bank level together
leftRightBank <- cbind(waterData$left_bank, waterData$right_bank)
# return vector of pairwise maximum
apply(leftRightBank, 1, max)
}
isOutOfBound <- function(waterLevel, groundLevel, maxBank, groundLevelOffset = -1, maxBankOffset = 4) {
groundLevelOffset < -1
maxBankOffset <- 4
str(waterLevel)
str(groundLevel)
str(maxBank)
str('-------------')
isOverGroundLevel <- waterLevel >= groundLevel + groundLevelOffset
isUnderMaxBank <- waterLevel <= maxBank + maxBankOffset
!(isOverGroundLevel & isUnderMaxBank)
}
searchBoundaryProblem <- function(data) {
data$max_bank <- getMaxBank(data)
hasBoundaryProblem <- mapply(isOutOfBound, data$water1, data$ground_level, data$max_bank)
data[hasBoundaryProblem,]
}
rs <- dbGetQuery(con, "SELECT
data_log.code,
data_log.date,
data_log.time,
data_log.water1,
tele_wl_detail.code,
tele_wl_detail.left_bank,
tele_wl_detail.right_bank,
tele_wl_detail.ground_level
FROM
data_log
inner join tele_wl_detail on tele_wl_detail.code = data_log.code
where data_log.water1 is not null and data_log.date = DATE '2012-02-28'
and tele_wl_detail.left_bank > tele_wl_detail.right_bank
limit 2000")
rs$max_bank <- getMaxBank(rs)
rs
dbDisconnect(con);
# dbUnloadDriver(drv);
searchBoundaryProblem(x)
class(x$ground_level)
class(as.numeric(x$ground_level))
as.numeric(x$ground_level)
x
library(RUnit);
source('boundary.R')
test.suite <- defineTestSuite("boundary",
dirs = file.path("tests"),
testFileRegexp = '^boundary\\d+\\.R')
test.result <- runTestSuite(test.suite)
printTextProtocol(test.result)
install.packages('RUnit')
library(RUnit);
source('boundary.R')
test.suite <- defineTestSuite("boundary",
dirs = file.path("tests"),
testFileRegexp = '^boundary\\d+\\.R')
test.result <- runTestSuite(test.suite)
printTextProtocol(test.result)
library(RUnit);
source('boundary.R')
test.suite <- defineTestSuite("boundary",
dirs = file.path("tests"),
testFileRegexp = '^boundary\\d+\\.R')
test.result <- runTestSuite(test.suite)
printTextProtocol(test.result)
NA > 1
NA < 1
na
NA
max(NA,1)
?max
?all
c(NA, NA)
x <- c(NA, NA)
all.equal(NA, x)
NA = NA
NA == NA
all(is.na(x))
is.na(x)
library(RUnit);
source('boundary.R')
test.suite <- defineTestSuite("boundary",
dirs = file.path("tests"),
testFileRegexp = '^boundary\\d+\\.R')
test.result <- runTestSuite(test.suite)
printTextProtocol(test.result)
compareFunction <- function(...) {
params <- list(...)
if( all(is.na(params)) ) {
NA
} else {
max(params, na.rm=TRUE)
}
}
compareFunction(10, 20)
compareFunction <- function(...) {
params <- ...
if( all(is.na(params)) ) {
NA
} else {
max(params, na.rm=TRUE)
}
}
compareFunction(10, 20)
...
max(c(1,2,3,4,5))
max(list(1,2,3,4,5))
?max
library(RUnit);
source('boundary.R')
test.suite <- defineTestSuite("boundary",
dirs = file.path("tests"),
testFileRegexp = '^boundary\\d+\\.R')
test.result <- runTestSuite(test.suite)
printTextProtocol(test.result)
compareFunction <- function(...) {
params <- list(...)
str(params)
if( all(is.na(params)) ) {
NA
} else {
max(params, na.rm=TRUE)
}
}
compareFunction(1,2,3,4,5)
compareFunction(c(1,2,3,4,5))
library(RUnit);
source('boundary.R')
test.suite <- defineTestSuite("boundary",
dirs = file.path("tests"),
testFileRegexp = '^boundary\\d+\\.R')
test.result <- runTestSuite(test.suite)
printTextProtocol(test.result)
library(RUnit);
source('boundary.R')
test.suite <- defineTestSuite("boundary",
dirs = file.path("tests"),
testFileRegexp = '^boundary\\d+\\.R')
test.result <- runTestSuite(test.suite)
printTextProtocol(test.result)
library(RUnit);
source('boundary.R')
test.suite <- defineTestSuite("boundary",
dirs = file.path("tests"),
testFileRegexp = '^boundary\\d+\\.R')
test.result <- runTestSuite(test.suite)
printTextProtocol(test.result)
source('db_connection.R')
# Calculate max bank of water data by max(leftBank, rightBank)
getMaxBank <- function(leftBank, rightBank) {
if( is.na(leftBank) & is.na(rightBank)) {
NA
} else {
max(leftBank, rightBank, na.rm = TRUE)
}
}
isOutOfBound <- function(waterLevel, groundLevel, maxBank, groundLevelOffset = -1, maxBankOffset = 4) {
groundLevelOffset < -1
maxBankOffset <- 4
isOverGroundLevel <- waterLevel >= groundLevel + groundLevelOffset
isUnderMaxBank <- waterLevel <= maxBank + maxBankOffset
!(isOverGroundLevel & isUnderMaxBank)
}
searchBoundaryProblem <- function(data) {
data$max_bank <- mapply(getMaxBank, data$left_bank, data$right_bank)
hasBoundaryProblem <- mapply(isOutOfBound, data$water1, data$ground_level, data$max_bank)
data[hasBoundaryProblem,]
}
rs <- dbGetQuery(con, "SELECT
data_log.code,
data_log.date,
data_log.time,
data_log.water1,
tele_wl_detail.left_bank,
tele_wl_detail.right_bank,
tele_wl_detail.ground_level
FROM
data_log
inner join tele_wl_detail on tele_wl_detail.code = data_log.code
where data_log.water1 is not null and data_log.date = DATE '2012-02-28'
and tele_wl_detail.left_bank > tele_wl_detail.right_bank
limit 20")
rs$max_bank <- getMaxBank(rs)
rs
#searchBoundaryProblem(rs)
dbDisconnect(con);
# dbUnloadDriver(drv);
?all
?some
??some
getDataBD <- function() {
# Condition: Passed if max_bank + 4 and ground_level - 1
# CHI001: Passed (Above right_bank but below left_bank)
# CHI002: Passed (Below both banks)
# KRN001: Below ground level
# KRN002: Above maxbank (left)
# KRN003: Above maxbank (right)
# KRN004: Below negative ground level
code <- c("CHI001", "CHI002", "KRN001", "KRN002", "KRN003", "KRN004")
date <- c("2012-06-08", "2012-06-08", "2012-06-08", "2012-06-08", "2012-06-08", "2012-06-08")
time <- c("17:00:00", "17:10:00", "17:20:00", "00:00:00", "00:10:00", "00:20:00")
water1       <- c(166.53, 0, 12.2, 136.06, 185.25, -15.432)
left_bank    <- c(175.937, 12.778, 175.937, 9.83, 165.7, 15.937)
right_bank   <- c(152.212, 15.14, 152.212, 15.412, 175.937, 25.23)
ground_level <- c(128.037, -2.341, 143.435, -2.2, 128.037, -13.512)
data.frame(
code=code,
date=date,
time=time,
water1=water1,
left_bank=left_bank,
right_bank=right_bank,
ground_level=ground_level,
stringsAsFactors=FALSE
)
}
test.getMaxBank <- function() {
left_bank    <- c(10.0, 20.0, 30.0, NA  , 10.0, NA)
right_bank   <- c(10.0, 30.0, 20.0, 10.0, NA  , NA)
expected <- c(10.0, 30.0, 30.0, 10.0, 10.0, NA)
actual <- mapply(getMaxBank, left_bank, right_bank)
mapply(checkEquals, expected, actual)
}
test.isOutOfBound <- function() {
waterLevel  <- c(10.0, 10.0, 10.0, 10.0, NA , 0.0, 0.0)
groundLevel <- c(0.0 , 11.0, 11.5, 10.0, 0.0, NA , 0.0)
maxBank     <- c(20.0, 6.0 , 20.0, 5.0 , 0.0, 0.0, NA )
expected <- c(FALSE, FALSE, TRUE, TRUE, FALSE, FALSE, FALSE)
actual <- mapply(isOutOfBound, waterLevel, groundLevel, maxBank)
mapply(checkEquals, expected, actual)
}
test.searchBoundaryProblem <- function() {
data <- getDataBD()
results <- searchBoundaryProblem(data)
checkEquals("KRN001", results$code[1])
checkEquals("KRN002", results$code[2])
checkEquals("KRN003", results$code[3])
checkEquals("KRN004", results$code[4])
checkEquals(12.2, results$water1[1])
checkEquals(136.06, results$water1[2])
checkEquals(185.25, results$water1[3])
checkEquals(-15.432, results$water1[4])
checkEquals(175.937, results$max_bank[1])
checkEquals(15.412, results$max_bank[2])
checkEquals(175.937, results$max_bank[3])
checkEquals(25.230, results$max_bank[4])
}
test.deactivation <- function()
{
DEACTIVATED('Deactivating this test function')
}
library(RUnit);
source('boundary.R')
test.suite <- defineTestSuite("boundary",
dirs = file.path("tests"),
testFileRegexp = '^boundary\\d+\\.R')
test.result <- runTestSuite(test.suite)
printTextProtocol(test.result)
is.na(NA,1)
is.na(c(NA,1)
is.na(c(NA,1)
is.na(c(NA,1))
library(RUnit);
source('boundary.R')
test.suite <- defineTestSuite("boundary",
dirs = file.path("tests"),
testFileRegexp = '^boundary\\d+\\.R')
test.result <- runTestSuite(test.suite)
printTextProtocol(test.result)
library(RUnit);
source('boundary.R')
test.suite <- defineTestSuite("boundary",
dirs = file.path("tests"),
testFileRegexp = '^boundary\\d+\\.R')
test.result <- runTestSuite(test.suite)
printTextProtocol(test.result)
any(is.na(c(NA, 1)))
any(is.na(c(1, 1)))
library(RUnit);
source('boundary.R')
test.suite <- defineTestSuite("boundary",
dirs = file.path("tests"),
testFileRegexp = '^boundary\\d+\\.R')
test.result <- runTestSuite(test.suite)
printTextProtocol(test.result)
